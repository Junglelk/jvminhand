package heap

import "jvmgo/jvmgo/ch06/rtda"

/*
	运行Java程序时，Java虚拟机需要使用内存来存放各式各样的数据。Java虚拟机规范把这些内存区域叫做运行时数据区。
	运行时数据区可以分为两类：
		1. 多线程共享的；
		2. 线程私有的。
	多线程共享的运行时数据区需要在Java虚拟机启动时创建，Java虚拟机退出时销毁。
	线程私有的运行时数据区在创建线程时创建，线程退出时销毁。

	多线程共享的内存区域主要存放两类数据：类数据和类实例（即对象）。
	对象数据存放在堆（Heap）中，类数据在方法区（Method Area）中。堆数据由垃圾收集器定期清理。类数据包括字段和方法信息、方法的字节码、运行时常量池等。
	逻辑上讲，方法区实际上也是堆的一部分。

	线程私有的运行时数据区用于辅助执行Java字节码。每个线程都有自己的 pc 寄存器（Program Counter）和Java虚拟机栈（JVM Stack）。
	Java虚拟机栈又由栈帧（Stack Frame，后简称帧）构成，帧中保存方法执行时的状态，包括局部变量表（Local Variable）和操作数栈（Operand Stack）等。
	在任意时刻，某一线程肯定在执行某个方法，这个方法叫做该线程的当前方法；执行该方法的帧叫做线程的当前帧。声明该方法的类叫做当前类。
	如果当前方法是Java方法，则 pc 寄存器中存放当前正在执行的Java虚拟机指令的地址，否则，当前方法是本地方法，pc 寄存器中的值无明确定义。

	可以如下勾勒出运行时数据区的逻辑结构：
	+---------------------------+---------------------------+
	|			 		Run-Time Data Area		   			|
	+---------------------------+---------------------------+
	|			Thread			|			Heap			|
	|	+--------------------+	|  +---------------------+	|
	|	|	 	  PC 		 |	|  |	  Method Area	 |	|
	|	+--------------------+	|  | +-----------------+ |	|
	|				    		|  | |		Class	   | |  |
	|	+--------------------+	|  | +-----------------+ |	|
	|	|	   JVM Stack  	 |	|  | |	  Run-Time	   | |	|
	|	| +----------------+ |	|  | |	Constant Pool  | |	|
	|	| |		Frame	   | |	|  | +-----------------+ |	|
	|	| +----------------+ |	|  +---------------------+	|
	|	| |	Local Variable | |  |							|
	|	| +----------------+ |  |  +---------------------+	|
	|	| |	Operand Stack  | |	|  |		Object		 |  |
	|	| +----------------+ |	|  +---------------------+  |
	|	+--------------------+	|							|
	|				    		|							|
	+---------------------------+---------------------------+

	实际上，Java虚拟机规范对运行时数据区的规定相当宽松。以堆为例：堆可以是连续的，也可以不连续。堆大小可固定，也可在运行时动态扩展。可以使用垃圾回收，也可以不使用垃圾回收。
	----Java命令提供了 -Xms 和 -Xmx 两个非标准选项，用来调整堆的初始大小和最大大小。

	Java虚拟机可以操作两类数据：基本数据（primitive type）和引用类型（reference type）。
	基本类型的变量存放的是数据本身，引用类型的变量存放的是对象的引用。真正的对象数据在堆中分配。
	此变量包括类变量（静态字段）、实例变量（非静态变量）、数组元素、方法参数和局部变量等等。

	基本数据类型又可以分为布尔类型（Boolean Type）和数字类型（Numeric Type），数字类型有整型（integral type）和浮点型（float-point type）。引用类型分为 3 种：类类型、接口类型和数组类型。
	类类型指向类实例，数组类型指向数组实例，接口类型引用指向实现了该接口的类或者数组实例。引用类型有个特殊的值 null ，表示该引用不指向任何对象。
	此外还有一种数据类型叫 returnAddress ，它和 jsr、ret、ret_w 指令一起用来实现 finally 子句，但自Java 6 开始，Oracle 的 Java 编译器已经不再使用这三条指令了。

*/

// Slots LocalVars的实例可以视为一个数组，该数组的每一个实例可以容纳一个int、float或引用值，也可以使用两个位置来存放double或long
// 可能是当时作者的go版本较低原文为 “rtda包已经依赖了heap包，而Go语言的包又不能重复依赖，所以heap包中的go文件是无法导入rtda包的”
// 所以原实现是将Slot结构体和LocalVars重新在heap包内写了一份，但目前来看，好像是可以直接使用的，但为了方便，此处重定义了LocalVars结构为Slots
// 如有问题，后续再做修改
type Slots rtda.LocalVars

// Object 在结构体中添加两个字段，一个存放对象的Class指针，一个存放实例变量
// 类的字段可以有原始数据类型，也可以有引用类型，正好可以对应上述两个字段
// 随后我们的问题是确定变量的数目和位置，前者数类的字段数即可，后者在数字段时给字段编号即可
type Object struct {
	class *Class
	field Slots
}

func newSlots(count uint) Slots {
	if count > 0 {
		return make([]rtda.Slot, count)
	}
	return nil
}
